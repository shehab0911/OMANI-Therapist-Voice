{"ast":null,"code":"export async function startRecording(onStop) {\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: true\n  });\n  // Use browser-supported format (webm)\n  const mediaRecorder = new MediaRecorder(stream, {\n    mimeType: 'audio/webm'\n  });\n  const audioChunks = [];\n  mediaRecorder.ondataavailable = event => audioChunks.push(event.data);\n  mediaRecorder.onstop = () => {\n    const audioBlob = new Blob(audioChunks, {\n      type: 'audio/webm'\n    });\n    onStop(audioBlob);\n  };\n  mediaRecorder.start();\n  return mediaRecorder;\n}\nexport async function startStreamingRecording(onChunk, onStop) {\n  const stream = await navigator.mediaDevices.getUserMedia({\n    audio: true\n  });\n  const mediaRecorder = new MediaRecorder(stream, {\n    mimeType: 'audio/webm'\n  });\n  mediaRecorder.ondataavailable = event => {\n    if (event.data && event.data.size > 0) {\n      onChunk(event.data);\n    }\n  };\n  mediaRecorder.onstop = onStop;\n  mediaRecorder.start(250); // Emit chunks every 250ms\n  return mediaRecorder;\n}\nexport function stopRecording(mediaRecorder) {\n  if (mediaRecorder && mediaRecorder.state !== \"inactive\") {\n    mediaRecorder.stop();\n  }\n}","map":{"version":3,"names":["startRecording","onStop","stream","navigator","mediaDevices","getUserMedia","audio","mediaRecorder","MediaRecorder","mimeType","audioChunks","ondataavailable","event","push","data","onstop","audioBlob","Blob","type","start","startStreamingRecording","onChunk","size","stopRecording","state","stop"],"sources":["F:/TRAE/omn/frontend/src/audioUtils.ts"],"sourcesContent":["export async function startRecording(onStop: (audioBlob: Blob) => void) {\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n  // Use browser-supported format (webm)\n  const mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });\n  const audioChunks: Blob[] = [];\n  mediaRecorder.ondataavailable = (event) => audioChunks.push(event.data);\n  mediaRecorder.onstop = () => {\n    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });\n    onStop(audioBlob);\n  };\n  mediaRecorder.start();\n  return mediaRecorder;\n}\n\nexport async function startStreamingRecording(onChunk: (chunk: Blob) => void, onStop: () => void) {\n  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n  const mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });\n  mediaRecorder.ondataavailable = (event) => {\n    if (event.data && event.data.size > 0) {\n      onChunk(event.data);\n    }\n  };\n  mediaRecorder.onstop = onStop;\n  mediaRecorder.start(250); // Emit chunks every 250ms\n  return mediaRecorder;\n}\n\nexport function stopRecording(mediaRecorder: MediaRecorder) {\n  if (mediaRecorder && mediaRecorder.state !== \"inactive\") {\n    mediaRecorder.stop();\n  }\n}\n"],"mappings":"AAAA,OAAO,eAAeA,cAAcA,CAACC,MAAiC,EAAE;EACtE,MAAMC,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;IAAEC,KAAK,EAAE;EAAK,CAAC,CAAC;EACzE;EACA,MAAMC,aAAa,GAAG,IAAIC,aAAa,CAACN,MAAM,EAAE;IAAEO,QAAQ,EAAE;EAAa,CAAC,CAAC;EAC3E,MAAMC,WAAmB,GAAG,EAAE;EAC9BH,aAAa,CAACI,eAAe,GAAIC,KAAK,IAAKF,WAAW,CAACG,IAAI,CAACD,KAAK,CAACE,IAAI,CAAC;EACvEP,aAAa,CAACQ,MAAM,GAAG,MAAM;IAC3B,MAAMC,SAAS,GAAG,IAAIC,IAAI,CAACP,WAAW,EAAE;MAAEQ,IAAI,EAAE;IAAa,CAAC,CAAC;IAC/DjB,MAAM,CAACe,SAAS,CAAC;EACnB,CAAC;EACDT,aAAa,CAACY,KAAK,CAAC,CAAC;EACrB,OAAOZ,aAAa;AACtB;AAEA,OAAO,eAAea,uBAAuBA,CAACC,OAA8B,EAAEpB,MAAkB,EAAE;EAChG,MAAMC,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;IAAEC,KAAK,EAAE;EAAK,CAAC,CAAC;EACzE,MAAMC,aAAa,GAAG,IAAIC,aAAa,CAACN,MAAM,EAAE;IAAEO,QAAQ,EAAE;EAAa,CAAC,CAAC;EAC3EF,aAAa,CAACI,eAAe,GAAIC,KAAK,IAAK;IACzC,IAAIA,KAAK,CAACE,IAAI,IAAIF,KAAK,CAACE,IAAI,CAACQ,IAAI,GAAG,CAAC,EAAE;MACrCD,OAAO,CAACT,KAAK,CAACE,IAAI,CAAC;IACrB;EACF,CAAC;EACDP,aAAa,CAACQ,MAAM,GAAGd,MAAM;EAC7BM,aAAa,CAACY,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;EAC1B,OAAOZ,aAAa;AACtB;AAEA,OAAO,SAASgB,aAAaA,CAAChB,aAA4B,EAAE;EAC1D,IAAIA,aAAa,IAAIA,aAAa,CAACiB,KAAK,KAAK,UAAU,EAAE;IACvDjB,aAAa,CAACkB,IAAI,CAAC,CAAC;EACtB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}